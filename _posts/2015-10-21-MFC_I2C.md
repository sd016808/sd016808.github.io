---
layout: post
title: 'MFC裡使用NI 讀寫I2C'
author: 'James Peng'
tags: ['Visual C++']
---



## I2C-bus 簡介 ##


I²C（Inter-Integrated Circuit）是內部整合電路的稱呼，是一種串列通訊匯流排，使用內送流量備援容錯機制從架構，由飛利浦公司在1980年代為了讓主機板、嵌入式系統或手機用以連接低速週邊裝置而發展。I²C的正確讀法為"I-squared-C" ，而"I-two-C"則是另一種錯誤但被廣泛使用的讀法，在中國則多以"I方C"稱之。截至2006年11月1日為止，使用I²C協定不需要為其專利付費，但製造商仍然需要付費以獲得I²C從屬裝置位址。


-----------------

#### I²C 設計概說 ####
I²C只使用兩條雙向開放汲極（Open Drain）（串列資料（SDA）及串列時脈（SCL））並利用電阻將電位上拉。I²C允許相當大的工作電壓範圍，但典型的電壓準位為+3.3V或+5v。

I²C的參考設計使用一個7位元長度的位址空間但保留了16個位址，所以在一組匯流排最多可和112個節點通訊。常見的I²C匯流排依傳輸速率的不同而有不同的模式：標準模式（100 Kbit/s）、低速模式（10 Kbit/s），但時脈頻率可被允許下降至零，這代表可以暫停通訊。而新一代的I²C匯流排可以和更多的節點（支援10位元長度的位址空間）以更快的速率通訊：快速模式（400 Kbit/s）、高速模式（3.4 Mbit/s）。

雖然最大的節點數目是被位址空間所限制住，但實際上也會被匯流排上的總電容所限制住，一般而言為400 pF。

![](..\images\2015-10-21-MFC_I2C\kDzNDeY.png)

#### Write 原理 ####


|   | S | Device Address | Write bit | A | Deta Address (offset、CMD Code) | A | Write Data | ... | Nack | P |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 解釋： | 開始 | 裝置位址 | 寫入bit | 板子回應 | 資料位址 | 板子回應 | 寫入資料 | ... | 星號 | 結束 |
| 範例：| S | 0x58 | w  |   |   |   |   | ... | * | P |



----------


#### Read 原理 ####

|   | S | Device Address | Read bit | A | Read Deta | A | Write Data | ... | Nack | P |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 解釋： | 開始 | 裝置位址 | 讀取bit | 讀取資料 | 資料位址 | 板子回應 | 寫入資料 | ... | 星號 | 結束 |
| 範例：| S | 0x58 |  r |   |   |   |   | ... | * | P |


----------



#### Random Read 原理 ####


|   | S | Device Address | Write bit | Deta Address (offset、CMD Code) | Sr (Repeat start) | Deta Address (offset、CMD Code) | Read bit | A | Read Data | ... | Nack | P |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |-- | -- | -- |
| 解釋： | 開始 | 裝置位址 | 寫入bit | 資料位址 | 重送開始 | 裝置位址 | 讀取bit | 板子回應 | 讀取資料 | ... | 星號 | 結束 |
| 範例：| S | 0x58 | w  |   |  S | 0x58  |  r |   |   | ... | * | P |


I2C詳情請參閱：

1. I²C - 維基百科，自由的百科全書，http://zh.wikipedia.org/wiki/I%C2%B2C
2. 《I2C-bus specification and user manual》，http://www.nxp.com/documents/user_manual/UM10204.pdf


延伸關鍵字：

* SMBus(系統管理總線)
* PMBus(電源管理總線)
* IPMI(智能平台管理總線)
* DDC(顯示數據通道)
* ATCA(高級電信架構)


-----------------

#### 需求 ####

要讀取和寫入 I2C bus


-----------------

#### 硬體型號 ####

Aardvark I2C/SPI Host Adapter (Part Number:TP240141)

http://www.totalphase.com/products/aardvark-i2cspi/

* Part Number: TP240141
* Distribution: Physical Shipment
* Availability: In-Stock
* Price: $275.00

![](..\images\2015-10-21-MFC_I2C\SSJWcMU.jpg)

Aardvark I2C/SPI主機適配器簡介：

Aardvark I2C/SPI主機適配器是一個通過上 ControlCenter 軟件界面的快速強大的I2C及SPI總線主機適配。                           

 

Aardvark I2C/SPI主機適配器允許開發者通過自己定義一個 Windows, Linux, 或者Mac OS X Pc 到的嵌入式系統，支持 Master-Slave 用 I2C 和 SPI 規程傳送串行規範標準。

Aardvark I2C/SPI主機適配器可用於工業，汽車，消費，醫療電子等各領域的I2C/SPI應用的開發和芯品燒錄。

I2C/SPI/MDIO EEPROM/Flash主機適配器。可用自定義Script控制Adaptor自動對EEPROM、Flash等編程、測試。


    功能特性：
    支持I2C主從模式切換最高速率達到400KHZ
    支持I2C多主控制
    SPI最高主模式可達到8MHZ
    SPI從模式最高可達到4MHZ
    配有多路可選GPIO引腳輸入/輸出
    支持Windows,Linux,Mac OS等多種操作系統
    提供靈活API接口庫
    可輸出5V電源供電
    兼容DDC SMBUS PMBUS SBBUS IPMI TWI等多種總線協議

-----------------

#### Downalod  ####

| USB Drivers  | http://www.totalphase.com/products/usb-drivers-windows |
| -- | -- |
| Aardvark Software API | http://www.totalphase.com/products/aardvark-software-api |
| Control Center Software | http://www.totalphase.com/products/control-center/ |


![](..\images\2015-10-21-MFC_I2C\qXwZM5E.png)


-----------------

#### 是否Work?  ####
![](..\images\2015-10-21-MFC_I2C\3TedLvY.png)

根目錄裡有個 aainfo.exe 可以簡單測試是否抓的到硬體。

![](..\images\2015-10-21-MFC_I2C\WG3NfXN.png)

有連上硬體了！～

-----------------

#### Build C Code  ####

解壓縮後，有支援 C, C#, Python, .NET, VB.NET, 和 VB6。

要注意DLL有分 32-bit 和 64-bit，用錯DLL會讀取不到。

目錄裡，*.c 和 *.h 和 專案檔 分開放。

![](..\images\2015-10-21-MFC_I2C\pz6lRym.png)

專案檔是放在子目錄裡，MSVC應該是舊版VC6專案檔，MSVC2008是2008的專案檔。

![](..\images\2015-10-21-MFC_I2C\NVN1mNj.png)

要用之前，請把 *.c 和 *.h 拷貝一份到專案目錄

![](..\images\2015-10-21-MFC_I2C\iFXXSH0.png)

然後直接用Visual Studio 2013開啟 Makefile.sln，升級專案。

![](..\images\2015-10-21-MFC_I2C\IRLH9bj.png)

F7 編譯，全部成功

~~~text
1>------ 已開始建置:  專案: aadetect, 組態: Release Win32 ------
2>------ 已開始建置:  專案: aagpio, 組態: Release Win32 ------
3>------ 已開始建置:  專案: aai2c_eeprom, 組態: Release Win32 ------
4>------ 已開始建置:  專案: aai2c_file, 組態: Release Win32 ------
1>  aadetect.c
2>  aagpio.c
2>  aardvark.c
1>  aardvark.c
4>  aai2c_file.c
4>  aardvark.c
3>  aai2c_eeprom.c
2>  正在產生程式碼...
3>  aardvark.c
1>  正在產生程式碼...
4>  正在產生程式碼...
1>  aadetect.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aadetect.exe
2>  aagpio.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aagpio.exe
4>  aai2c_file.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aai2c_file.exe
5>------ 已開始建置:  專案: aai2c_slave, 組態: Release Win32 ------
6>------ 已開始建置:  專案: aalights, 組態: Release Win32 ------
3>  正在產生程式碼...
7>------ 已開始建置:  專案: aamonitor, 組態: Release Win32 ------
6>  aalights.c
5>  aai2c_slave.c
6>  aardvark.c
5>  aardvark.c
7>  aamonitor.c
7>  aardvark.c
3>  aai2c_eeprom.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aai2c_eeprom.exe
6>  正在產生程式碼...
5>  正在產生程式碼...
8>------ 已開始建置:  專案: aaspi_eeprom, 組態: Release Win32 ------
7>  正在產生程式碼...
8>  aardvark.c
6>  aalights.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aalights.exe
5>  aai2c_slave.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aai2c_slave.exe
9>------ 已開始建置:  專案: aaspi_file, 組態: Release Win32 ------
7>  aamonitor.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aamonitor.exe
10>------ 已開始建置:  專案: aaspi_slave, 組態: Release Win32 ------
9>  aardvark.c
10>  aardvark.c
8>  aaspi_eeprom.c
8>  正在產生程式碼...
9>  aaspi_file.c
9>  正在產生程式碼...
10>  aaspi_slave.c
8>  aaspi_eeprom.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aaspi_eeprom.exe
10>  正在產生程式碼...
9>  aaspi_file.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aaspi_file.exe
10>  aaspi_slave.vcxproj -> D:\Work\try\aardvark-api-windows-i686-v5.15\c\MSVC2008\.\..\_output\aaspi_slave.exe
========== 建置:  10 成功、0 失敗、0 最新、0 略過 ==========

~~~


記得把 aardvark.dll 複製一份到 _output 目錄下

![](..\images\2015-10-21-MFC_I2C\iBcpsZk.png)


方能正常執行。


-----------------

#### Software API Sample 描述  ####

| 專案 | 描述 |
| -- | -- |
| aadetect |  檢測連接到系統的 Aardvark 設備。 |
| aalights | Flash LEDs 連接到一個 Philips PCA9554D I/O port expander as found on the Activity Board. |
| aai2c_eeprom | 讀寫到 I2C 序列 EEPROM。 |
| aaspi_eeprom | 讀寫到 SPI 序列 EEPROM。 |
| aai2c_file aai2c_slave | 示演 I2C slave 的功能。舉個例子： 可以在使用兩個Aardvark時，先執行 aai2c_slave 和 第一台 Aardvark 裝置，去等待一個新的 slave 傳輸。然後, 在另一個 shell 介面, 執行 aai2c_file 去傳輸一個 binary file 透過 第二台 Aardvark 裝置。 |
| aaspi_file aaspi_slave | 示演 SPI slave 的功能. 舉個例子： 可以在使用兩個Aardvark時，先執行 aaspi_slave 和 第一台 Aardvark 裝置，去等待一個新的 slave 傳輸。然後, 在另一個 shell 介面, 執行 aaspi_file 去傳輸一個 binary file 透過 第二台 Aardvark 裝置。 |
| aagpio | 示演一些簡單的 GPIO tests 用單一 Aardvark adapter.  這些結果可以被 oscilloscope 或 multimeter 驗證. |
| aamonitor | I2C Bus 監控功能。 舉個例子：可以在使用兩個Aardvark時，第一個Aardvark 可以監測第二個Aardvark 的 I2C EEPROM之間的傳輸。 |

-----------------

#### aadetect ####

~~~text
> aadetect
1 device(s) found:
    port=0   (avail) (2222-333333)
~~~

![](..\images\2015-10-21-MFC_I2C\ZmmTo59.png)



-----------------

#### 硬體接法  ####

![](..\images\2015-10-21-MFC_I2C\a29MB2C.png)

三條線：
1. 接地 GUN
2. 串行數據線 SDA
3. 串行時鐘線 SCL

然後夾起來 搞定！
    

-----------------

#### aai2c_eeprom  ####


~~~text

> aai2c_eeprom 0 400 zero 0x50 0 32
Bitrate set to 400 kHz
Zeroed EEPROM


> aai2c_eeprom 0 400 read 0x50 0 32
Bitrate set to 400 kHz

Data read from device:
0000:  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
0010:  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00


> aai2c_eeprom 0 400 write 0x50 0 32
Bitrate set to 400 kHz
Wrote to EEPROM


> aai2c_eeprom 0 400 read 0x50 0 32
Bitrate set to 400 kHz

Data read from device:
0000:  01 02 03 04 05 06 07 08  09 0a 0b 0c 0d 0e 0f 10
0010:  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 00


> aai2c_eeprom 0 400 zero 0x50 8 4
Bitrate set to 400 kHz
Zeroed EEPROM


> aai2c_eeprom 0 400 read 0x50 0 32
Bitrate set to 400 kHz

Data read from device:
0000:  01 02 03 04 05 06 07 08  00 00 00 00 0d 0e 0f 10
0010:  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 00

~~~


----------


#### 讀取  ####

  | Name    | 第幾個參數|  example |
  |  --     | --        |  -- |
  | port    |  1 |   0  |
  | bitrate |  2 | 400 |
  | command |  3 | read、write、zero |
  | Slave Device Address | 4  | 0x58 |
  | Offset address    |  5 | 2A 3A 1E CE |
  | length  |  6 | 32 |
  
  

~~~text
aai2c_eeprom 0 400 write 0x58 "5E 00 2A 04 c4" 32
aai2c_eeprom 0 400 read 0x58 0 32
~~~


----------


#### 讀寫EEPROM  ####


~~~cpp
void i2cReadWrite(int port, int bitrate, CString cmd, int device, int addr, int length)
{
	CString strTemp;
	CString strResult;
	strResult.Empty();
	Aardvark handle;
	int bus_timeout;

	const char *command;

	command = CIICBusControlGUIDlg::CStringToChar(cmd);
	//addr = (u08)strtol(argv[5], 0, 0);

	// Open the device
	handle = aa_open(port);
	if (handle <= 0) {
		strTemp.Format(_T("Unable to open Aardvark device on port %d\n Error code = %d\r\n"), port, handle);
		AfxMessageBox(strTemp);
	}
	else
	{
	

		// Ensure that the I2C subsystem is enabled
		aa_configure(handle, AA_CONFIG_SPI_I2C);

		// Enable the I2C bus pullup resistors (2.2k resistors).
		// This command is only effective on v2.0 hardware or greater.
		// The pullup resistors on the v1.02 hardware are enabled by default.
		aa_i2c_pullup(handle, AA_I2C_PULLUP_BOTH);

		// Power the EEPROM using the Aardvark adapter's power supply.
		// This command is only effective on v2.0 hardware or greater.
		// The power pins on the v1.02 hardware are not enabled by default.
		aa_target_power(handle, AA_TARGET_POWER_BOTH);

		// Set the bitrate
		bitrate = aa_i2c_bitrate(handle, bitrate);
		strTemp.Format(_T("Bitrate set to %d kHz\r\n"), bitrate);
		strResult += strTemp;

		// Set the bus lock timeout
		bus_timeout = aa_i2c_bus_timeout(handle, BUS_TIMEOUT);
		strTemp.Format(_T("Bus lock timeout set to %d ms\r\n"), bus_timeout);
		strResult += strTemp;

		// Perform the operation
		if (strcmp(command, "write") == 0) {
			CIICBusControlGUIDlg::_writeMemory(handle, device, addr, length, 0);
			strTemp.Format(_T("Wrote to EEPROM\r\n"));
			strResult += strTemp;
		}
		else if (strcmp(command, "read") == 0) {
			strResult += CIICBusControlGUIDlg::_readMemory(handle, device, addr, length);
		}
		else if (strcmp(command, "zero") == 0) {
			CIICBusControlGUIDlg::_writeMemory(handle, device, addr, length, 1);
			strTemp.Format(_T("Zeroed EEPROM\r\n"));
			strResult += strTemp;
		}
		else {
			strTemp.Format(_T("unknown command: %s\r\n"), command);
			strResult += strTemp;
		}

		// Close the device and exit
		aa_close(handle);

		strEditMonitor += strResult;
		UpdateData(FALSE);

	}

}

void _writeMemory(Aardvark handle, u08 device, u08 addr, u16 length,
	int zero)
{
	u16 i, n;
	u08 data_out[1 + PAGE_SIZE];

	// Write to the I2C EEPROM
	//
	// The AT24C02 EEPROM has 8 byte pages.  Data can written
	// in pages, to reduce the number of overall I2C transactions
	// executed through the Aardvark adapter.
	n = 0;
	while (n < length) {
		// Fill the packet with data
		data_out[0] = addr;

		// Assemble a page of data
		i = 1;
		do {
			data_out[i++] = zero ? 0 : (u08)n;
			++addr; ++n;
		} while (n < length && (addr & (PAGE_SIZE - 1)));

		// Write the address and data
		aa_i2c_write(handle, device, AA_I2C_NO_FLAGS, i, data_out);
		aa_sleep_ms(10);
	}
}

CString _readMemory(Aardvark handle, u08 device, u08 addr, u16 length)
{
	CString strTemp;
	CString strResult;
	strTemp.Empty();
	int count, i;
	u08 *data_in = (u08 *)malloc(length);

	// Write the address
	aa_i2c_write(handle, device, AA_I2C_NO_STOP, 1, &addr);

	count = aa_i2c_read(handle, device, AA_I2C_NO_FLAGS, length, data_in);
	if (count < 0) {
		printf("error: %s\n", aa_status_string(count));
		return _T("");
	}
	if (count == 0) {
		printf("error: no bytes read\n");
		printf("  are you sure you have the right slave address?\n");
		return _T("");
	}
	else if (count != length) {
		printf("error: read %d bytes (expected %d)\n", count, length);
	}

	// Dump the data to the screen
	printf("\nData read from device:");
	for (i = 0; i < count; ++i) {
		if ((i & 0x0f) == 0)
		{
			//strTemp.Format(_T("\n%04x:  "), addr + i);
		}
		strTemp.Format(_T("%02x "), data_in[i] & 0xff);
		strResult += strTemp;
		//printf("%02x ", data_in[i] & 0xff);
		if (((i + 1) & 0x07) == 0)  printf(" ");
	}
	printf("\n");

	// Free the data_in pointer
	free(data_in);
	return strResult;
}

char* CStringToChar(CString cStr)
{
	size_t i;
	char* str;
	int sizeOfString = (cStr.GetLength() + 1);
	LPTSTR pStrTmp = new TCHAR[sizeOfString];
	_tcscpy_s(pStrTmp, sizeOfString, cStr);
	str = new char[sizeOfString];
	wcstombs_s(&i, str, sizeOfString, pStrTmp, _TRUNCATE);
	return str;
}

~~~


----------


#### 監控MONITER  ####


~~~cpp
int GetDevicesCount()
{
	u16 ports[16];
	u32 unique_ids[16];
	int nelem = 16;

	// Find all the attached devices
	int count = aa_find_devices_ext(nelem, ports, nelem, unique_ids);
	return count;
}

u16   data[BUFFER_SIZE];
void dump(Aardvark handle)
{
	strEditMonitor.Empty();

	CString strTemp = _T("");
	CString strResult = _T("");
	int result;
	u16 last_data1 = 0;
	u16 last_data0 = 0;

	// Wait for data on the bus
	strTemp.Format(_T("Waiting %d ms for first transaction...\r\n"), INITIAL_TIMEOUT);
	strResult += strTemp;

	result = aa_async_poll(handle, INITIAL_TIMEOUT);
	if (result == AA_ASYNC_NO_DATA) {
		strTemp.Format(_T("  no data pending.\r\n"));
		strResult += strTemp;
	}

	strTemp.Format(_T("  data received.\r\n"));
	strResult += strTemp;

	// Loop until aa_async_poll times out
	for (;;) {
		// Read the next monitor transaction.
		// This function has an internal timeout (see datasheet), though
		// since we have already checked for data using aa_async_poll,
		// the timeout should never be exercised.
		int num_bytes = aa_i2c_monitor_read(handle, BUFFER_SIZE, data);
		int i;

		if (num_bytes < 0) {
			strTemp.Format(_T("error: %s\r\n"), aa_status_string(num_bytes));
			strResult += strTemp;
		}

		for (i = 0; i < num_bytes; ++i) {
			// Check for start condition
			if (data[i] == AA_I2C_MONITOR_CMD_START) {
				char *buffer;
				CString strBuffer;

				time_t res;
				res = time(NULL);

				buffer = asctime(localtime(&res));
				buffer[strlen(buffer) - 1] = 0;
				strBuffer = buffer;
				strTemp.Format(_T("\r\n%s - [S] "), strBuffer);
				strResult += strTemp;
			}

			// Check for stop condition
			else if (data[i] == AA_I2C_MONITOR_CMD_STOP) {
				strTemp.Format(_T("[P]\r\n"));
				strResult += strTemp;
			}

			else {
				int nack = (data[i] & AA_I2C_MONITOR_NACK);
				// 7-bit addresses
				if (last_data0 == AA_I2C_MONITOR_CMD_START &&
					((data[i] & 0xf8) != 0xf0 || nack)) {

					CString strNack = nack ? _T("*") : _T("");
					CString strRW = data[i] & 0x01 ? _T("r") : _T("w");
					int iData = (data[i] & 0xff) >> 1;

					strTemp.Format(_T("<%02x:%s>%s "), iData,
						strRW,
						strNack);
					strResult += strTemp;
				}

				// 10-bit addresses
				// See Philips specification for more details.
				else if (last_data1 == AA_I2C_MONITOR_CMD_START &&
					(last_data0 & 0xf8) == 0xf0) {

					CString strNack = nack ? _T("*") : _T("");
					CString strRW = last_data0 & 0x01 ? _T("r") : _T("w");
					int iData = ((last_data0 << 7) & 0x300) | (data[i] & 0xff);

					strTemp.Format(_T("<%03x:%c>%s "),
						iData,
						strRW,
						strNack);
					strResult += strTemp;
				}

				// Normal data
				else if (last_data0 != AA_I2C_MONITOR_CMD_START) {
					CString strNack = nack ? _T("*") : _T("");
					int iData = data[i] & 0xff;

					strTemp.Format(_T("%02x%s "), iData,
						strNack);
					strResult += strTemp;
				}
			}

			last_data1 = last_data0;
			last_data0 = data[i];
			fflush(stdout);
		}

		strTemp.Format(_T("\r\nWaiting %d ms for subsequent transaction...\r\n"), INTERVAL_TIMEOUT);
		strResult += strTemp;

		result = aa_async_poll(handle, INTERVAL_TIMEOUT);
		if (result == AA_ASYNC_NO_DATA) {
			strTemp.Format(_T("  no more data pending.\r\n"));
			strResult += strTemp;
			break;
		}
		strTemp.Format(_T(" data received.\r\n\r\n"));
		strResult += strTemp;
	}
	strEditMonitor = strResult;
	UpdateData(FALSE);
}
~~~



----------


#### aardvark.cpp(VS2013可編譯)  ####

~~~cpp
/*=========================================================================
| Aardvark Interface Library
|--------------------------------------------------------------------------
| Copyright (c) 2002-2008 Total Phase, Inc.
| All rights reserved.
| www.totalphase.com
|
| Redistribution and use in source and binary forms, with or without
| modification, are permitted provided that the following conditions
| are met:
|
| - Redistributions of source code must retain the above copyright
|   notice, this list of conditions and the following disclaimer.
|
| - Redistributions in binary form must reproduce the above copyright
|   notice, this list of conditions and the following disclaimer in the
|   documentation and/or other materials provided with the distribution.
|
| - Neither the name of Total Phase, Inc. nor the names of its
|   contributors may be used to endorse or promote products derived from
|   this software without specific prior written permission.
|
| THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
| "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
| LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
| FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
| COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
| INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
| BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
| LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
| CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
| LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
| ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
| POSSIBILITY OF SUCH DAMAGE.
|--------------------------------------------------------------------------
| To access Aardvark devices through the API:
|
| 1) Use one of the following shared objects:
|      aardvark.so      --  Linux shared object
|      aardvark.dll     --  Windows dynamic link library
|
| 2) Along with one of the following language modules:
|      aardvark.c/h     --  C/C++ API header file and interface module
|      aardvark_py.py   --  Python API
|      aardvark.bas     --  Visual Basic 6 API
|      aardvark.cs      --  C# .NET source
|      aardvark_net.dll --  Compiled .NET binding
 ========================================================================*/


/*=========================================================================
| INCLUDES
 ========================================================================*/
/* This #include can be customized to conform to the user's build paths. */
#include "stdafx.h"
#include "aardvark.h"


/*=========================================================================
| VERSION CHECK
 ========================================================================*/
#define AA_CFILE_VERSION   0x050a   /* v5.10 */
#define AA_REQ_SW_VERSION  0x050a   /* v5.10 */

/*
 * Make sure that the header file was included and that
 * the version numbers match.
 */
#ifndef AA_HEADER_VERSION
#  error Unable to include header file. Please check include path.

#elif AA_HEADER_VERSION != AA_CFILE_VERSION
#  error Version mismatch between source and header files.

#endif


/*=========================================================================
| DEFINES
 ========================================================================*/
#define API_NAME                     "aardvark"
#define API_DEBUG                    AA_DEBUG
#define API_OK                       AA_OK
#define API_UNABLE_TO_LOAD_LIBRARY   AA_UNABLE_TO_LOAD_LIBRARY
#define API_INCOMPATIBLE_LIBRARY     AA_INCOMPATIBLE_LIBRARY
#define API_UNABLE_TO_LOAD_FUNCTION  AA_UNABLE_TO_LOAD_FUNCTION
#define API_HEADER_VERSION           AA_HEADER_VERSION
#define API_REQ_SW_VERSION           AA_REQ_SW_VERSION


/*=========================================================================
| LINUX AND DARWIN SUPPORT
 ========================================================================*/
#if defined(__APPLE_CC__) && !defined(DARWIN)
#define DARWIN
#endif

#if defined(linux) || defined(DARWIN)

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>

#ifdef DARWIN
#define DLOPEN_NO_WARN
extern int _NSGetExecutablePath (char *buf, unsigned long *bufsize);
#endif

#include <dlfcn.h>

#define DLL_HANDLE  void *
#define MAX_SO_PATH 256

static char SO_NAME[MAX_SO_PATH+1] = API_NAME ".so";

/*
 * These functions allow the Linux behavior to emulate
 * the Windows behavior as specified below in the Windows
 * support section.
 * 
 * First, search for the shared object in the application
 * binary path, then in the current working directory.
 * 
 * Searching the application binary path requires /proc
 * filesystem support, which is standard in 2.4.x kernels.
 * 
 * If the /proc filesystem is not present, the shared object
 * will not be loaded from the execution path unless that path
 * is either the current working directory or explicitly
 * specified in LD_LIBRARY_PATH.
 */
static int _checkPath (const char *path) {
    char *filename = (char *)malloc(strlen(path) +1 + strlen(SO_NAME) +1);
    int   fd;

    // Check if the file is readable
    sprintf(filename, "%s/%s", path, SO_NAME);
    fd = open(filename, O_RDONLY);
    if (fd >= 0) {
        strncpy(SO_NAME, filename, MAX_SO_PATH);
        close(fd);
    }

    // Clean up and exit
    free(filename);
    return (fd >= 0);
}

static int _getExecPath (char *path, unsigned long maxlen) {
#ifdef linux
    return readlink("/proc/self/exe", path, maxlen);
#endif

#ifdef DARWIN
    _NSGetExecutablePath(path, &maxlen);
    return maxlen;
#endif
}

static void _setSearchPath () {
    char  path[MAX_SO_PATH+1];
    int   count;
    char *p;

    /* Make sure that SO_NAME is not an absolute path. */
    if (SO_NAME[0] == '/')  return;

    /* Check the execution directory name. */
    memset(path, 0, sizeof(path));
    count = _getExecPath(path, MAX_SO_PATH);

    if (count > 0) {
        char *p = strrchr(path, '/');
        if (p == path)  ++p;
        if (p != 0)     *p = '\0';

        /* If there is a match, return immediately. */
        if (_checkPath(path))  return;
    }

    /* Check the current working directory. */
    p = getcwd(path, MAX_SO_PATH);
    if (p != 0)  _checkPath(path);
}

#endif


/*=========================================================================
| WINDOWS SUPPORT
 ========================================================================*/
#if defined(WIN32) || defined(_WIN32)

#include <stdio.h>
#include <windows.h>

#define DLL_HANDLE           HINSTANCE
#define dlopen(name, flags)  LoadLibraryA(name)
#define dlsym(handle, name)  GetProcAddress(handle, name)
#define dlerror()            "Exiting program"
#define SO_NAME              API_NAME ".dll"

/*
 * Use the default Windows DLL loading rules:
 *   1.  The directory from which the application binary was loaded.
 *   2.  The application's current directory.
 *   3a. [Windows NT/2000/XP only] 32-bit system directory
 *       (default: c:\winnt\System32)
 *   3b. 16-bit system directory
 *       (default: c:\winnt\System or c:\windows\system)
 *   4.  The windows directory
 *       (default: c:\winnt or c:\windows)
 *   5.  The directories listed in the PATH environment variable
 */
static void _setSearchPath () {
    /* Do nothing */
}

#endif


/*=========================================================================
| SHARED LIBRARY LOADER
 ========================================================================*/
/* The error conditions can be customized depending on the application. */
static void *_loadFunction (const char *name, int *result) {
    static DLL_HANDLE handle = 0;
    void * function = 0;

    /* Load the shared library if necessary */
    if (handle == 0) {
        u32 (*version) (void);
        u16 sw_version;
        u16 api_version_req;

        _setSearchPath();
        handle = dlopen(SO_NAME, RTLD_LAZY);
        if (handle == 0) {
#if API_DEBUG
            fprintf(stderr, "Unable to load %s\n", SO_NAME);
            fprintf(stderr, "%s\n", dlerror());
#endif
            *result = API_UNABLE_TO_LOAD_LIBRARY;
            return 0;
        }

        //version = (void *)dlsym(handle, "aa_c_version");
		version = (u32(__cdecl *)(void))dlsym(handle, "aa_c_version");
        if (version == 0) {
#if API_DEBUG
            fprintf(stderr, "Unable to bind aa_c_version() in %s\n",
                    SO_NAME);
            fprintf(stderr, "%s\n", dlerror());
#endif
            handle  = 0;
            *result = API_INCOMPATIBLE_LIBRARY;
            return 0;
        }

        sw_version      = (u16)((version() >>  0) & 0xffff);
        api_version_req = (u16)((version() >> 16) & 0xffff);
        if (sw_version  < API_REQ_SW_VERSION ||
            API_HEADER_VERSION < api_version_req)
        {
#if API_DEBUG
            fprintf(stderr, "\nIncompatible versions:\n");

            fprintf(stderr, "  Header version  = v%d.%02d  ",
                    (API_HEADER_VERSION >> 8) & 0xff, API_HEADER_VERSION & 0xff);

            if (sw_version < API_REQ_SW_VERSION)
                fprintf(stderr, "(requires library >= %d.%02d)\n",
                        (API_REQ_SW_VERSION >> 8) & 0xff,
                        API_REQ_SW_VERSION & 0xff);
            else
                fprintf(stderr, "(library version OK)\n");
                        
                   
            fprintf(stderr, "  Library version = v%d.%02d  ",
                    (sw_version >> 8) & 0xff,
                    (sw_version >> 0) & 0xff);

            if (API_HEADER_VERSION < api_version_req)
                fprintf(stderr, "(requires header >= %d.%02d)\n",
                        (api_version_req >> 8) & 0xff,
                        (api_version_req >> 0) & 0xff);
            else
                fprintf(stderr, "(header version OK)\n");
#endif
            handle  = 0;
            *result = API_INCOMPATIBLE_LIBRARY;
            return 0;
        }
    }

    /* Bind the requested function in the shared library */
    function = (void *)dlsym(handle, name);
    *result  = function ? API_OK : API_UNABLE_TO_LOAD_FUNCTION;
    return function;
}


/*=========================================================================
| FUNCTIONS
 ========================================================================*/
static int (*c_aa_find_devices) (int, u16 *) = 0;
int aa_find_devices (
    int   num_devices,
    u16 * devices
)
{
    if (c_aa_find_devices == 0) {
        int res = 0;
		if (!(c_aa_find_devices = (int(__cdecl *)(int, u16 *))_loadFunction("c_aa_find_devices", &res)))
            return res;
    }
    return c_aa_find_devices(num_devices, devices);
}


static int (*c_aa_find_devices_ext) (int, u16 *, int, u32 *) = 0;
int aa_find_devices_ext (
    int   num_devices,
    u16 * devices,
    int   num_ids,
    u32 * unique_ids
)
{
    if (c_aa_find_devices_ext == 0) {
        int res = 0;
		if (!(c_aa_find_devices_ext = (int(__cdecl *)(int, u16 *, int, u32 *))_loadFunction("c_aa_find_devices_ext", &res)))
            return res;
    }
    return c_aa_find_devices_ext(num_devices, devices, num_ids, unique_ids);
}


static Aardvark (*c_aa_open) (int) = 0;
Aardvark aa_open (
    int port_number
)
{
    if (c_aa_open == 0) {
        int res = 0;
		if (!(c_aa_open = (Aardvark(__cdecl *)(int))_loadFunction("c_aa_open", &res)))
            return res;
    }
    return c_aa_open(port_number);
}


static Aardvark (*c_aa_open_ext) (int, AardvarkExt *) = 0;
Aardvark aa_open_ext (
    int           port_number,
    AardvarkExt * aa_ext
)
{
    if (c_aa_open_ext == 0) {
        int res = 0;
		if (!(c_aa_open_ext = (Aardvark(__cdecl *)(int, AardvarkExt *))_loadFunction("c_aa_open_ext", &res)))
            return res;
    }
    return c_aa_open_ext(port_number, aa_ext);
}


static int (*c_aa_close) (Aardvark) = 0;
int aa_close (
    Aardvark aardvark
)
{
    if (c_aa_close == 0) {
        int res = 0;
		if (!(c_aa_close = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_close", &res)))
            return res;
    }
    return c_aa_close(aardvark);
}


static int (*c_aa_port) (Aardvark) = 0;
int aa_port (
    Aardvark aardvark
)
{
    if (c_aa_port == 0) {
        int res = 0;
		if (!(c_aa_port = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_port", &res)))
            return res;
    }
    return c_aa_port(aardvark);
}


static int (*c_aa_features) (Aardvark) = 0;
int aa_features (
    Aardvark aardvark
)
{
    if (c_aa_features == 0) {
        int res = 0;
		if (!(c_aa_features = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_features", &res)))
            return res;
    }
    return c_aa_features(aardvark);
}


static u32 (*c_aa_unique_id) (Aardvark) = 0;
u32 aa_unique_id (
    Aardvark aardvark
)
{
    if (c_aa_unique_id == 0) {
        int res = 0;
		if (!(c_aa_unique_id = (u32(__cdecl *)(Aardvark))_loadFunction("c_aa_unique_id", &res)))
            return res;
    }
    return c_aa_unique_id(aardvark);
}


static const char * (*c_aa_status_string) (int) = 0;
const char * aa_status_string (
    int status
)
{
    if (c_aa_status_string == 0) {
        int res = 0;
		if (!(c_aa_status_string = (const char *(__cdecl *)(int))_loadFunction("c_aa_status_string", &res)))
            return 0;
    }
    return c_aa_status_string(status);
}


static int (*c_aa_log) (Aardvark, int, int) = 0;
int aa_log (
    Aardvark aardvark,
    int      level,
    int      handle
)
{
    if (c_aa_log == 0) {
        int res = 0;
		if (!(c_aa_log = (int(__cdecl *)(Aardvark, int, int))_loadFunction("c_aa_log", &res)))
            return res;
    }
    return c_aa_log(aardvark, level, handle);
}


static int (*c_aa_version) (Aardvark, AardvarkVersion *) = 0;
int aa_version (
    Aardvark          aardvark,
    AardvarkVersion * version
)
{
    if (c_aa_version == 0) {
        int res = 0;
		if (!(c_aa_version = (int(__cdecl *)(Aardvark, AardvarkVersion *))_loadFunction("c_aa_version", &res)))
            return res;
    }
    return c_aa_version(aardvark, version);
}


static int (*c_aa_configure) (Aardvark, AardvarkConfig) = 0;
int aa_configure (
    Aardvark       aardvark,
    AardvarkConfig config
)
{
    if (c_aa_configure == 0) {
        int res = 0;
		if (!(c_aa_configure = (int(__cdecl *)(Aardvark, AardvarkConfig))_loadFunction("c_aa_configure", &res)))
            return res;
    }
    return c_aa_configure(aardvark, config);
}


static int (*c_aa_target_power) (Aardvark, u08) = 0;
int aa_target_power (
    Aardvark aardvark,
    u08      power_mask
)
{
    if (c_aa_target_power == 0) {
        int res = 0;
		if (!(c_aa_target_power = (int(__cdecl *)(Aardvark, u08))_loadFunction("c_aa_target_power", &res)))
            return res;
    }
    return c_aa_target_power(aardvark, power_mask);
}


static u32 (*c_aa_sleep_ms) (u32) = 0;
u32 aa_sleep_ms (
    u32 milliseconds
)
{
    if (c_aa_sleep_ms == 0) {
        int res = 0;
		if (!(c_aa_sleep_ms = (u32(__cdecl *)(u32))_loadFunction("c_aa_sleep_ms", &res)))
            return res;
    }
    return c_aa_sleep_ms(milliseconds);
}


static int (*c_aa_async_poll) (Aardvark, int) = 0;
int aa_async_poll (
    Aardvark aardvark,
    int      timeout
)
{
    if (c_aa_async_poll == 0) {
        int res = 0;
		if (!(c_aa_async_poll = (int(__cdecl *)(Aardvark, int)) _loadFunction("c_aa_async_poll", &res)))
            return res;
    }
    return c_aa_async_poll(aardvark, timeout);
}


static int (*c_aa_i2c_free_bus) (Aardvark) = 0;
int aa_i2c_free_bus (
    Aardvark aardvark
)
{
    if (c_aa_i2c_free_bus == 0) {
        int res = 0;
		if (!(c_aa_i2c_free_bus = (int(__cdecl *)(Aardvark)) _loadFunction("c_aa_i2c_free_bus", &res)))
            return res;
    }
    return c_aa_i2c_free_bus(aardvark);
}


static int (*c_aa_i2c_bitrate) (Aardvark, int) = 0;
int aa_i2c_bitrate (
    Aardvark aardvark,
    int      bitrate_khz
)
{
    if (c_aa_i2c_bitrate == 0) {
        int res = 0;
		if (!(c_aa_i2c_bitrate = (int(__cdecl *)(Aardvark, int))_loadFunction("c_aa_i2c_bitrate", &res)))
            return res;
    }
    return c_aa_i2c_bitrate(aardvark, bitrate_khz);
}


static int (*c_aa_i2c_bus_timeout) (Aardvark, u16) = 0;
int aa_i2c_bus_timeout (
    Aardvark aardvark,
    u16      timeout_ms
)
{
    if (c_aa_i2c_bus_timeout == 0) {
        int res = 0;
		if (!(c_aa_i2c_bus_timeout = (int(__cdecl *)(Aardvark, u16)) _loadFunction("c_aa_i2c_bus_timeout", &res)))
            return res;
    }
    return c_aa_i2c_bus_timeout(aardvark, timeout_ms);
}


static int (*c_aa_i2c_read) (Aardvark, u16, AardvarkI2cFlags, u16, u08 *) = 0;
int aa_i2c_read (
    Aardvark         aardvark,
    u16              slave_addr,
    AardvarkI2cFlags flags,
    u16              num_bytes,
    u08 *            data_in
)
{
    if (c_aa_i2c_read == 0) {
        int res = 0;
		if (!(c_aa_i2c_read = (int(__cdecl *)(Aardvark, u16, AardvarkI2cFlags, u16, u08 *)) _loadFunction("c_aa_i2c_read", &res)))
            return res;
    }
    return c_aa_i2c_read(aardvark, slave_addr, flags, num_bytes, data_in);
}


static int (*c_aa_i2c_read_ext) (Aardvark, u16, AardvarkI2cFlags, u16, u08 *, u16 *) = 0;
int aa_i2c_read_ext (
    Aardvark         aardvark,
    u16              slave_addr,
    AardvarkI2cFlags flags,
    u16              num_bytes,
    u08 *            data_in,
    u16 *            num_read
)
{
    if (c_aa_i2c_read_ext == 0) {
        int res = 0;
		if (!(c_aa_i2c_read_ext = (int(__cdecl *)(Aardvark, u16, AardvarkI2cFlags, u16, u08 *, u16 *))_loadFunction("c_aa_i2c_read_ext", &res)))
            return res;
    }
    return c_aa_i2c_read_ext(aardvark, slave_addr, flags, num_bytes, data_in, num_read);
}


static int (*c_aa_i2c_write) (Aardvark, u16, AardvarkI2cFlags, u16, const u08 *) = 0;
int aa_i2c_write (
    Aardvark         aardvark,
    u16              slave_addr,
    AardvarkI2cFlags flags,
    u16              num_bytes,
    const u08 *      data_out
)
{
    if (c_aa_i2c_write == 0) {
        int res = 0;
		if (!(c_aa_i2c_write = (int(__cdecl *)(Aardvark, u16, AardvarkI2cFlags, u16, const u08 *)) _loadFunction("c_aa_i2c_write", &res)))
            return res;
    }
    return c_aa_i2c_write(aardvark, slave_addr, flags, num_bytes, data_out);
}


static int (*c_aa_i2c_write_ext) (Aardvark, u16, AardvarkI2cFlags, u16, const u08 *, u16 *) = 0;
int aa_i2c_write_ext (
    Aardvark         aardvark,
    u16              slave_addr,
    AardvarkI2cFlags flags,
    u16              num_bytes,
    const u08 *      data_out,
    u16 *            num_written
)
{
    if (c_aa_i2c_write_ext == 0) {
        int res = 0;
		if (!(c_aa_i2c_write_ext = (int(__cdecl *)(Aardvark, u16, AardvarkI2cFlags, u16, const u08 *, u16 *)) _loadFunction("c_aa_i2c_write_ext", &res)))
            return res;
    }
    return c_aa_i2c_write_ext(aardvark, slave_addr, flags, num_bytes, data_out, num_written);
}


static int (*c_aa_i2c_write_read) (Aardvark, u16, AardvarkI2cFlags, u16, const u08 *, u16 *, u16, u08 *, u16 *) = 0;
int aa_i2c_write_read (
    Aardvark         aardvark,
    u16              slave_addr,
    AardvarkI2cFlags flags,
    u16              out_num_bytes,
    const u08 *      out_data,
    u16 *            num_written,
    u16              in_num_bytes,
    u08 *            in_data,
    u16 *            num_read
)
{
    if (c_aa_i2c_write_read == 0) {
        int res = 0;
		if (!(c_aa_i2c_write_read = (int(__cdecl *)(Aardvark, u16, AardvarkI2cFlags, u16, const u08 *, u16 *, u16, u08 *, u16 *)) _loadFunction("c_aa_i2c_write_read", &res)))
            return res;
    }
    return c_aa_i2c_write_read(aardvark, slave_addr, flags, out_num_bytes, out_data, num_written, in_num_bytes, in_data, num_read);
}


static int (*c_aa_i2c_slave_enable) (Aardvark, u08, u16, u16) = 0;
int aa_i2c_slave_enable (
    Aardvark aardvark,
    u08      addr,
    u16      maxTxBytes,
    u16      maxRxBytes
)
{
    if (c_aa_i2c_slave_enable == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_enable = (int(__cdecl *)(Aardvark, u08, u16, u16)) _loadFunction("c_aa_i2c_slave_enable", &res)))
            return res;
    }
    return c_aa_i2c_slave_enable(aardvark, addr, maxTxBytes, maxRxBytes);
}


static int (*c_aa_i2c_slave_disable) (Aardvark) = 0;
int aa_i2c_slave_disable (
    Aardvark aardvark
)
{
    if (c_aa_i2c_slave_disable == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_disable = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_i2c_slave_disable", &res)))
            return res;
    }
    return c_aa_i2c_slave_disable(aardvark);
}


static int (*c_aa_i2c_slave_set_response) (Aardvark, u08, const u08 *) = 0;
int aa_i2c_slave_set_response (
    Aardvark    aardvark,
    u08         num_bytes,
    const u08 * data_out
)
{
    if (c_aa_i2c_slave_set_response == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_set_response = (int(__cdecl *)(Aardvark, u08, const u08 *))_loadFunction("c_aa_i2c_slave_set_response", &res)))
            return res;
    }
    return c_aa_i2c_slave_set_response(aardvark, num_bytes, data_out);
}


static int (*c_aa_i2c_slave_write_stats) (Aardvark) = 0;
int aa_i2c_slave_write_stats (
    Aardvark aardvark
)
{
    if (c_aa_i2c_slave_write_stats == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_write_stats = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_i2c_slave_write_stats", &res)))
            return res;
    }
    return c_aa_i2c_slave_write_stats(aardvark);
}


static int (*c_aa_i2c_slave_read) (Aardvark, u08 *, u16, u08 *) = 0;
int aa_i2c_slave_read (
    Aardvark aardvark,
    u08 *    addr,
    u16      num_bytes,
    u08 *    data_in
)
{
    if (c_aa_i2c_slave_read == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_read = (int(__cdecl *)(Aardvark, u08 *, u16, u08 *))_loadFunction("c_aa_i2c_slave_read", &res)))
            return res;
    }
    return c_aa_i2c_slave_read(aardvark, addr, num_bytes, data_in);
}


static int (*c_aa_i2c_slave_write_stats_ext) (Aardvark, u16 *) = 0;
int aa_i2c_slave_write_stats_ext (
    Aardvark aardvark,
    u16 *    num_written
)
{
    if (c_aa_i2c_slave_write_stats_ext == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_write_stats_ext = (int(__cdecl *)(Aardvark, u16 *)) _loadFunction("c_aa_i2c_slave_write_stats_ext", &res)))
            return res;
    }
    return c_aa_i2c_slave_write_stats_ext(aardvark, num_written);
}


static int (*c_aa_i2c_slave_read_ext) (Aardvark, u08 *, u16, u08 *, u16 *) = 0;
int aa_i2c_slave_read_ext (
    Aardvark aardvark,
    u08 *    addr,
    u16      num_bytes,
    u08 *    data_in,
    u16 *    num_read
)
{
    if (c_aa_i2c_slave_read_ext == 0) {
        int res = 0;
		if (!(c_aa_i2c_slave_read_ext = (int(__cdecl *)(Aardvark, u08 *, u16, u08 *, u16 *))_loadFunction("c_aa_i2c_slave_read_ext", &res)))
            return res;
    }
    return c_aa_i2c_slave_read_ext(aardvark, addr, num_bytes, data_in, num_read);
}


static int (*c_aa_i2c_monitor_enable) (Aardvark) = 0;
int aa_i2c_monitor_enable (
    Aardvark aardvark
)
{
    if (c_aa_i2c_monitor_enable == 0) {
        int res = 0;
		if (!(c_aa_i2c_monitor_enable = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_i2c_monitor_enable", &res)))
            return res;
    }
    return c_aa_i2c_monitor_enable(aardvark);
}


static int (*c_aa_i2c_monitor_disable) (Aardvark) = 0;
int aa_i2c_monitor_disable (
    Aardvark aardvark
)
{
    if (c_aa_i2c_monitor_disable == 0) {
        int res = 0;
		if (!(c_aa_i2c_monitor_disable = (int(__cdecl *)(Aardvark)) _loadFunction("c_aa_i2c_monitor_disable", &res)))
            return res;
    }
    return c_aa_i2c_monitor_disable(aardvark);
}


static int (*c_aa_i2c_monitor_read) (Aardvark, u16, u16 *) = 0;
int aa_i2c_monitor_read (
    Aardvark aardvark,
    u16      num_bytes,
    u16 *    data
)
{
    if (c_aa_i2c_monitor_read == 0) {
        int res = 0;
		if (!(c_aa_i2c_monitor_read = (int(__cdecl *)(Aardvark, u16, u16 *)) _loadFunction("c_aa_i2c_monitor_read", &res)))
            return res;
    }
    return c_aa_i2c_monitor_read(aardvark, num_bytes, data);
}


static int (*c_aa_i2c_pullup) (Aardvark, u08) = 0;
int aa_i2c_pullup (
    Aardvark aardvark,
    u08      pullup_mask
)
{
    if (c_aa_i2c_pullup == 0) {
        int res = 0;
		if (!(c_aa_i2c_pullup = (int(__cdecl *)(Aardvark, u08)) _loadFunction("c_aa_i2c_pullup", &res)))
            return res;
    }
    return c_aa_i2c_pullup(aardvark, pullup_mask);
}


static int (*c_aa_spi_bitrate) (Aardvark, int) = 0;
int aa_spi_bitrate (
    Aardvark aardvark,
    int      bitrate_khz
)
{
    if (c_aa_spi_bitrate == 0) {
        int res = 0;
		if (!(c_aa_spi_bitrate = (int(__cdecl *)(Aardvark, int)) _loadFunction("c_aa_spi_bitrate", &res)))
            return res;
    }
    return c_aa_spi_bitrate(aardvark, bitrate_khz);
}


static int (*c_aa_spi_configure) (Aardvark, AardvarkSpiPolarity, AardvarkSpiPhase, AardvarkSpiBitorder) = 0;
int aa_spi_configure (
    Aardvark            aardvark,
    AardvarkSpiPolarity polarity,
    AardvarkSpiPhase    phase,
    AardvarkSpiBitorder bitorder
)
{
    if (c_aa_spi_configure == 0) {
        int res = 0;
		if (!(c_aa_spi_configure = (int(__cdecl *)(Aardvark, AardvarkSpiPolarity, AardvarkSpiPhase, AardvarkSpiBitorder))_loadFunction("c_aa_spi_configure", &res)))
            return res;
    }
    return c_aa_spi_configure(aardvark, polarity, phase, bitorder);
}


static int (*c_aa_spi_write) (Aardvark, u16, const u08 *, u16, u08 *) = 0;
int aa_spi_write (
    Aardvark    aardvark,
    u16         out_num_bytes,
    const u08 * data_out,
    u16         in_num_bytes,
    u08 *       data_in
)
{
    if (c_aa_spi_write == 0) {
        int res = 0;
		if (!(c_aa_spi_write = (int(__cdecl *)(Aardvark, u16, const u08 *, u16, u08 *)) _loadFunction("c_aa_spi_write", &res)))
            return res;
    }
    return c_aa_spi_write(aardvark, out_num_bytes, data_out, in_num_bytes, data_in);
}


static int (*c_aa_spi_slave_enable) (Aardvark) = 0;
int aa_spi_slave_enable (
    Aardvark aardvark
)
{
    if (c_aa_spi_slave_enable == 0) {
        int res = 0;
		if (!(c_aa_spi_slave_enable = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_spi_slave_enable", &res)))
            return res;
    }
    return c_aa_spi_slave_enable(aardvark);
}


static int (*c_aa_spi_slave_disable) (Aardvark) = 0;
int aa_spi_slave_disable (
    Aardvark aardvark
)
{
    if (c_aa_spi_slave_disable == 0) {
        int res = 0;
		if (!(c_aa_spi_slave_disable = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_spi_slave_disable", &res)))
            return res;
    }
    return c_aa_spi_slave_disable(aardvark);
}


static int (*c_aa_spi_slave_set_response) (Aardvark, u08, const u08 *) = 0;
int aa_spi_slave_set_response (
    Aardvark    aardvark,
    u08         num_bytes,
    const u08 * data_out
)
{
    if (c_aa_spi_slave_set_response == 0) {
        int res = 0;
		if (!(c_aa_spi_slave_set_response = (int(__cdecl *)(Aardvark, u08, const u08 *))_loadFunction("c_aa_spi_slave_set_response", &res)))
            return res;
    }
    return c_aa_spi_slave_set_response(aardvark, num_bytes, data_out);
}


static int (*c_aa_spi_slave_read) (Aardvark, u16, u08 *) = 0;
int aa_spi_slave_read (
    Aardvark aardvark,
    u16      num_bytes,
    u08 *    data_in
)
{
    if (c_aa_spi_slave_read == 0) {
        int res = 0;
		if (!(c_aa_spi_slave_read = (int(__cdecl *)(Aardvark, u16, u08 *))_loadFunction("c_aa_spi_slave_read", &res)))
            return res;
    }
    return c_aa_spi_slave_read(aardvark, num_bytes, data_in);
}


static int (*c_aa_spi_master_ss_polarity) (Aardvark, AardvarkSpiSSPolarity) = 0;
int aa_spi_master_ss_polarity (
    Aardvark              aardvark,
    AardvarkSpiSSPolarity polarity
)
{
    if (c_aa_spi_master_ss_polarity == 0) {
        int res = 0;
		if (!(c_aa_spi_master_ss_polarity = (int(__cdecl *)(Aardvark, AardvarkSpiSSPolarity))_loadFunction("c_aa_spi_master_ss_polarity", &res)))
            return res;
    }
    return c_aa_spi_master_ss_polarity(aardvark, polarity);
}


static int (*c_aa_gpio_direction) (Aardvark, u08) = 0;
int aa_gpio_direction (
    Aardvark aardvark,
    u08      direction_mask
)
{
    if (c_aa_gpio_direction == 0) {
        int res = 0;
		if (!(c_aa_gpio_direction = (int(__cdecl *)(Aardvark, u08)) _loadFunction("c_aa_gpio_direction", &res)))
            return res;
    }
    return c_aa_gpio_direction(aardvark, direction_mask);
}


static int (*c_aa_gpio_pullup) (Aardvark, u08) = 0;
int aa_gpio_pullup (
    Aardvark aardvark,
    u08      pullup_mask
)
{
    if (c_aa_gpio_pullup == 0) {
        int res = 0;
		if (!(c_aa_gpio_pullup = (int(__cdecl *)(Aardvark, u08))_loadFunction("c_aa_gpio_pullup", &res)))
            return res;
    }
    return c_aa_gpio_pullup(aardvark, pullup_mask);
}


static int (*c_aa_gpio_get) (Aardvark) = 0;
int aa_gpio_get (
    Aardvark aardvark
)
{
    if (c_aa_gpio_get == 0) {
        int res = 0;
		if (!(c_aa_gpio_get = (int(__cdecl *)(Aardvark))_loadFunction("c_aa_gpio_get", &res)))
            return res;
    }
    return c_aa_gpio_get(aardvark);
}


static int (*c_aa_gpio_set) (Aardvark, u08) = 0;
int aa_gpio_set (
    Aardvark aardvark,
    u08      value
)
{
    if (c_aa_gpio_set == 0) {
        int res = 0;
		if (!(c_aa_gpio_set = (int(__cdecl *)(Aardvark, u08))_loadFunction("c_aa_gpio_set", &res)))
            return res;
    }
    return c_aa_gpio_set(aardvark, value);
}


static int (*c_aa_gpio_change) (Aardvark, u16) = 0;
int aa_gpio_change (
    Aardvark aardvark,
    u16      timeout
)
{
    if (c_aa_gpio_change == 0) {
        int res = 0;
		if (!(c_aa_gpio_change = (int(__cdecl *)(Aardvark, u16))_loadFunction("c_aa_gpio_change", &res)))
            return res;
    }
    return c_aa_gpio_change(aardvark, timeout);
}
~~~


----------


## 參考: ##

* http://opencores.org/websvn,filedetails?repname=i2cslave&path=%2Fi2cslave%2Ftrunk%2Fsw%2Faardvark_c%2Fi2cSlaveTest.c
* http://www.totalphase.com/support/articles/200468316-Aardvark-I2C-SPI-Host-Adapter-User-Manual
* http://www.codeforge.cn/read/209023/aai2c_eeprom.c__html
* 
